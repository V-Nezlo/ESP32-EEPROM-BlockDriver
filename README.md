# ESP32 EEPROM Block Driver

Драйвер, организующий блоковый доступ к памяти EEPROM для ESP32
Главная задача драйвера - организовать удобный интерфейс работы с EEPROM из любой точки программы.
Основу драйвера составляет "блок" - область выделенной энергонезависимой памяти для хранения там произвольной информации.

## Возможности

* Создание "блоков" произвольного размера, их запись, чтение и валидация
* Валидация данных блока
* Исключено чтение мусора, пересечение блоков, повторное создание блоков
* Интерфейс обеспечивает точку доступа к блокам в любом месте программы
* Контроль целостности записи блоков

## Особенности

Данный драйвер не создает "блоковую" структуру внутри энергонезависимой памяти, он создает маску, которая накладывается на эту память. Данные о блоке выглядят следующим образом:
```sh
char name - Имя блока
size_t address - Адрес начала блока
size_t size - Размер блока
uint16_t crc - Контрольная сумма блока
```
Из этих данных в энергонезависимую память попадает только crc, сразу после обьекта хранения блока. Маска состоит из адреса блока и его размера.

## Использование

```sh
EepromBlock <size_t BlockCount, size_t EepromSize = 512>
```
Конструктор без аргументов, в шаблоне задается число блоков и размер области EEPROM
```sh
bool createBlock(const char *aName, size_t aSize)
```
Создает блок с нужным именем и размером. Возвращает false если:
> Блок с таким именем уже существует
Длина имени больше максимально возможной
Пул блоков заполнен.

Иначе возвращает true и создает блок
```sh
bool writeBlock(const char *aName, const void* aData) const
```
Записывает данные в блок если блок существует. Иначе возвращает false. Размер данных должен совпадать с размером созданного блока

```sh
bool readBlock(const char *aName, void* aData) const
```
Читает данные из блока. Возвращает false если блок не найден или CRC не совпал.

## Пример использования

```sh
struct Patient // Структура, которая будет храниться в блоке
{
    char name[32];
    uint32_t money;
    uint8_t age;
    float psyHealth;
};

EepromBlock<2> eepromBlock; // Создали обьект драйвера, указали число блоков
eepromBlock.createBlock("Patient", sizeof(Patient)); // Создали блок размером структуры Patient

// Проверим, есть ли этот блок в памяти, и если есть - загрузим из него значения
Patient patient;
uint32_t patientMoney;
if (eepromBlock.readBlock("Patient", &patient)) {
    patientMoney = patient.money; // Значение будет прочитано из EEPROM
} else {
    // Тут мы точно знаем что данных в EEPROM нет, поэтому можем дать какое то дефолтное число
    patientMoney = 1000;
}

Patient newPatient {
    "Valera",
    5000,
    54,
    75.0
};

eepromBlock.writeBlock("Patient", &newPatient); // Записали данные 
```

## Особенности использования

Ключевым моментом является то чтобы пользователь не менял порядок вызова функций создания блоков. В драйвере отсутствует переаллокация блоков, поэтому перемешивание функций создания блоков между собой недопустимо. В драйвере отсутствует функция очистки EEPROM, поскольку если блок не найден в памяти - он не читается.
